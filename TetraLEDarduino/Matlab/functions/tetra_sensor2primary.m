function primaryStim = tetra_sensor2primary(dpy,stimLMS)%%    primaryStim = tetra_sensor2primary(dpy,stimLMS)%%AUTHOR: Wandell, Baseler, Press, Wade%DATE:   09.10.98 ,04.12.13%PURPOSE:%%   Calculate the primary (e.g. RGB) values (stimRGB.dir, stimRGB.scale) needed%   to create a  stimulus defined by stimLMS.dir, stimLMS.scale%   and the backRGB.dir backRGB.scale values.%%   This code works for a single stimLMS.dir vector, but%   stimLMS.scale may be a vector.%%   The returned values in stimRGB.scale are the RGB scale factors%   needed to obtain the specified LMS scale.  The cone contrast%   is calculated with respect to the background, as in%%     (lmsStimPlusBack - lmsBack) ./ lmsBack%%% ARGUMENTS%%  display:  .spectra contains the monitor spectral, is needed%  stimLMS:  .dir    is the color direction of the contrast stimulus%            .scale  is the scale factor%            When the stimLMS.dir is cone isolating, the%            scale factor is the same as contrast.  The%            definition of a single contrast value is problematic for other%            directions.%  backRGB:  (optional) .dir and  .scale define the mean RGB of background,%            so that backRGB.dir*backRGB.scale is a vector of%            linear rgb values.%  sensors:  (optional) A 361x3 matrix of sensor wavelength sensitivities.%            Default:  Stockman sensors.%% RETURNS%% stimLMS:   .maxScale   the largest permissible scale (re gamut%            and background).% stimRGB:  .dir    color direction of the rgb vector%           .scale  vector of scale values.%% SEE ALSO:%    findMaxConeScale(); RGB2Cone();%% ISSUES:%    It is a bit odd that we send in backRGB and stimLMS.  We did%   this because when we design the stimuli, we usually pick a%   background level near the middle of RGB, say [.5 .5 .5],%   without worrying much about it.  If we had sent in backLMS,%   it would usually be less convenient.%% 98.11.04 rfd: made stockman persistent so that it needn't be% 				loaded from disk each time this is called.% 98.11.17 rfd & wap: modified findMaxConeScale to%				properly scale the requested stimLMS so that%				the resulting stimuli will have the requested LMS.%				(See findMaxConeScale for details.)%% 04.12.13 arw : Modified to allow more than 3 sensors / primaries% Set up input defaults%sensors=dpy.coneSpectra; % nWaves x mSensors[AdjustedStimLMS, primaryStim] = tetra_findMaxSensorScale(dpy,stimLMS,sensors);% check whether contrast is higher than maximum available.% If it is we don't want it to error, but to output what the highest% possible contrast is and set it to that valuefor ii=1:length(AdjustedStimLMS.scale)    if (AdjustedStimLMS.scale(ii) > AdjustedStimLMS.maxScale)        if (AdjustedStimLMS.scale(ii)-AdjustedStimLMS.maxScale < 0.001) % Within rounding error - carry on..            AdjustedStimLMS.scale(ii) = AdjustedStimLMS.maxScale;        else            fprintf('Requested contrast ( %.3f) exceeds maximum (%.3f). Set to maximum instead\n', ...                AdjustedStimLMS.scale(ii),AdjustedStimLMS.maxScale);%             warning(str);            stimLMS.scale=AdjustedStimLMS.maxScale; % set to max and re-run the check            [AdjustedStimLMS, primaryStim] = tetra_findMaxSensorScale(dpy,stimLMS,sensors);            str2 = sprintf('Using maximum contrast available (%.3f)',AdjustedStimLMS.maxScale);            disp(str2);        end    end        primaryStim.scale(ii) = (AdjustedStimLMS.scale(ii)/AdjustedStimLMS.maxScale)*primaryStim.maxScale;    end%% original error code% for ii=1:length(AdjustedStimLMS.scale)% 	if (AdjustedStimLMS.scale(ii) > AdjustedStimLMS.maxScale)% 		if (AdjustedStimLMS.scale(ii)-AdjustedStimLMS.maxScale < 0.001) % Within rounding error - carry on..% 			AdjustedStimLMS.scale(ii) = AdjustedStimLMS.maxScale;% 		else% 	      	str = sprintf('Requested contrast ( %.3f) exceeds maximum (%.3f)\n', ...% 		  	AdjustedStimLMS.scale(ii),AdjustedStimLMS.maxScale);%       		error(str);% 		end% 	end%     % When stimRGB.scale equals stimRGB.maxScale,%     %%     %      stimLMS.scale = stimLMS.maxScale%     %%     % Everything is linear, so to obtain%     %%     %    stimLMS.scale = stimLMS.maxScale * (stimRGB.scale/stimRGB.maxScale)%     %%     % To solve for the stimRGB.scale that yields a stimLMS.scale,%     % we invert%     %%     LEDstim.scale(ii) = (AdjustedStimLMS.scale(ii)/AdjustedStimLMS.maxScale)*LEDstim.maxScale;%     %% endend