function [AdjustedStimLMS, LEDstim] = tetra_findMaxSensorScale(dpy,stimLMS,sensors)%% function [stimLMS, stimRGB] = pry_findMaxSensorScale(display,stimLMS,backRGB,sensors)%%AUTHOR: Wandell, Baseler, Press, Wade% Based on findMaxConeScale - for multispectral stimulation%DATE:   09.08.98%PURPOSE:%%   Calculate the maximum scale factor for the stimLMS given the%   background and display properties. %   %   When stimLMS.dir is in a cone isolating direction, the maximum%   scale factor is also to the max cone contrast available for that cone%   class. %   %   When stimLMS is not in a cone isolating direction, you are on%   your own.  That's why we call it scale.%  % ARGUMENTS%%  display:  .spectra is  a 361x3 display primaries%             %  stimLMS:  The field%             .dir     defines the color direction. By convention,%                X.dir is a n-vector with a maximum value of 1.0%             .scale   a vector of scale factors%             %  backRGB:  .dir    defines the color direciton. By convention,%                X.dir is a n-vector with a maximum value of 1.0%             .scale  a single scale factor%			  (optional, [0.5 0.5 0.5] default)%  sensors:  361x3 matrix of sensor wavelength sensitivities%             (optional, - use Baylor nomogram as default).%% RETURNS%            % stimLMS:  %           .maxScale is the highest scale factor.  This is the%           .maximum contrast when stimLMS.dir is cone isolating.%             % stimRGB: %          .dir is set to display primary direction corresponding to this%           lms direction. %% 10.29.98:	Swapped order of parameters.% 11.17.98: RFD & WAP: added scaling for lmsBack.%	NOTE: as of now, the RGB values returned are scaled by the%	background LMS so that they accurately reflect the requested%	LMS values in stimLMS.  (i.e., now you will get your requested%	LMS contrasts no matter what the background color direction.)% 04.13.13 ARW: Now accepts multispectral display and LMS% Set up input defaults%backLED.dir=dpy.backLED.dir(:);backLED.scale=dpy.backLED.scale;if ~isfield(dpy,'LEDspectra')  error('dpy.LEDspectra required');else  led2llms = sensors'*dpy.LEDspectra;  %check if nSensors == nPrimaries  if size(led2llms,1)==size(led2llms,2) %compare num rows to cols in the led2llms matrix      llms2led = inv(led2llms);  else %if the number of sensors and LEDs aren't the same, use pinv      llms2led = pinv(led2llms);   endend% Check whether the background RGB values are within the unit cube% meanLED = backLED.dir(:) .* backLED.scale;% err = checkRange(meanRGB,[0 0 0]',[1 1 1]');% if err ~= 0%   error('meanRGB out of range')% end%  Determine the background LMS direction lmsBack = led2llms*(meanLED);%  Scale stimulus LMS by the background LMSscaledStimLMS = stimLMS.dir(:) .* lmsBack;%  Determine the stimulus LED direction %  LEDstim.dir = llms2led*scaledStimLMS;% Now compute an error? This is the difference between the LMS stim we% asked for and the one we get back from the inverse. It >should< be very% small barring quantisation errors.%send out the led2llms and llms2led with LEDstimLEDstim.led2llms=led2llms;LEDstim.llms2led=llms2led;% Set the direction vector to be unit lengthLEDstim.dir = LEDstim.dir/sqrt(sum(abs(LEDstim.dir(:).^2)));% % Compute the ssq error between the actual LMS vals that we end up with and% % the requested vals. % LEDstimQuant=(round(LEDstim.dir*(2^dpy.bitDepth)))/2^(dpy.bitDepth)% LMSQuant=led2llms*LEDstimQuant(:);% normStimLMSDir=(stimLMS.dir(:)/sqrt(sum(abs(stimLMS.dir(:)).^2)))% errorL1=LMSQuant-(stimLMS.dir(:)/sqrt(sum(abs(stimLMS.dir(:)).^2)));% ssqErrorLMS=sqrt(sum(errorL1(:)))% fprintf('\nSSQ error = %d pc\n',ssqErrorLMS);%  Determine the stimulus LED direction %  %LEDstim.dir = scaledStimLMS\led2llms;%LEDstim.dir = LEDstim.dir/max(abs(LEDstim.dir));% We want to find the largest scale factor such that the% background plus stimulus fall on the edges of the unit cube.% We begin with the zero sides of the unit cube, % %      zsFactor*(stimRGB.dir) + meanRGB = 0% % Solving this equation for zsFactor, we obtain%sFactor = -(meanLED) ./ LEDstim.dir;%  The smallest scale factor that bumps into this side is% zsFactor = min(abs(sFactor));% Now find the sFactor that limits us on the 1 side of the unit RGB cube.% %       usFactor*stimRGB.dir + meanRGB = 1%   sFactor = (1 - meanLED) ./ LEDstim.dir;usFactor = min(abs(sFactor));%  Return the smaller of these two factors%  LEDstim.maxScale = 1; %min(zsFactor,usFactor);% Next, convert these values into LMS contrast terms.% % General discussion:% %  For each scale factor applied to the stimulus, there is a%  corresponding contrast.  But, this must be computed using both%  the stimLMS and the backLMS.  So, contrast and stimLMS.scale%  are not uniquely linked, but they depend on the background.% %  When stimRGB.scale is less than stimRGB.maxScale, we are sure that we%  are within the unit cube on this background.  What is the%  highest scale level we can obtain for the various cone classes%  at this edge? % % Compute the LMS coordinates of the [stimulus plus background] and% the background alone.  Use these to compute the max scale% factor we can use in the LMS direction.  This is the maximum% contrast when we are in a cone isolating direction.%  lmsStimPlusBack = ...    led2llms*(LEDstim.maxScale*LEDstim.dir + backLED.dir.*backLED.scale);AdjustedStimLMS.maxScale = max(abs((lmsStimPlusBack  - lmsBack) ./ lmsBack));AdjustedStimLMS.scale=stimLMS.scale;backLMS.dir = lmsBack;backLMS.scale = 1;return