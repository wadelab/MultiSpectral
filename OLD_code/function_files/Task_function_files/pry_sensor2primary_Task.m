function stimRGB = pry_sensor2primary_Task(dpy,stimLMS,backRGB,sensors,coneSensors)%%    stimRGB = pry_sensor2primary_Task(display,stimLMS,backRGB,sensors,coneSensors)%%AUTHOR: Wandell, Baseler, Press, Wade%DATE:   09.10.98 ,04.12.13%PURPOSE:%%   Calculate the primary (e.g. RGB) values (stimRGB.dir, stimRGB.scale) needed%   to create a  stimulus defined by stimLMS.dir, stimLMS.scale%   and the backRGB.dir backRGB.scale values. %   %   This code works for a single stimLMS.dir vector, but%   stimLMS.scale may be a vector.%   %   The returned values in stimRGB.scale are the RGB scale factors%   needed to obtain the specified LMS scale.  The cone contrast%   is calculated with respect to the background, as in%   %     (lmsStimPlusBack - lmsBack) ./ lmsBack%     %   % ARGUMENTS%%  display:  .spectra contains the monitor spectral, is needed%  stimLMS:  .dir    is the color direction of the contrast stimulus%            .scale  is the scale factor%            When the stimLMS.dir is cone isolating, the%            scale factor is the same as contrast.  The%            definition of a single contrast value is problematic for other%            directions. %  backRGB:  (optional) .dir and  .scale define the mean RGB of background,%            so that backRGB.dir*backRGB.scale is a vector of%            linear rgb values.%  sensors:  (optional) A 361x3 matrix of sensor wavelength sensitivities.%            Default:  Stockman sensors.%% RETURNS%            % stimLMS:   .maxScale   the largest permissible scale (re gamut%            and background).% stimRGB:  .dir    color direction of the rgb vector%           .scale  vector of scale values.%            % SEE ALSO:%    findMaxConeScale(); RGB2Cone();%% ISSUES:%    It is a bit odd that we send in backRGB and stimLMS.  We did%   this because when we design the stimuli, we usually pick a%   background level near the middle of RGB, say [.5 .5 .5],%   without worrying much about it.  If we had sent in backLMS,%   it would usually be less convenient.%   % 98.11.04 rfd: made stockman persistent so that it needn't be% 				loaded from disk each time this is called.		% 98.11.17 rfd & wap: modified findMaxConeScale to %				properly scale the requested stimLMS so that%				the resulting stimuli will have the requested LMS.%				(See findMaxConeScale for details.)%% 04.12.13 arw : Modified to allow more than 3 sensors / primaries % Set up input defaults%if ~exist('backRGB','var')  % disp('Cone2RGB: Using default background of [0.5 0.5 0.5]')  backRGB.dir = ones(size(dpy.spectra,2),1);  backRGB.scale = 0.5;endif ~exist('sensors','var')wavelengths=coneSensors.wavelengths;conepeaks=coneSensors.conepeaks; %% LMS: N.B. additional cone peaks can be added here e.g. for additional cones/melanopsinconeSpectra=BaylorNomogram(wavelengths(:),conepeaks(:));sensors=coneSpectra'; % nWaves x mSensorsendif ~isfield(dpy,'spectra')  error('The display structure requires a spectra field');else  displayP = dpy.spectra;end[stimLMS stimRGB] = pry_findMaxSensorScale_Task(dpy,stimLMS,backRGB,sensors,coneSensors); % This bit should be vectorized for ii=1:length(stimLMS.scale)	if (stimLMS.scale(ii) > stimLMS.maxScale)		if (stimLMS.scale(ii)-stimLMS.maxScale < 0.001) % Within rounding error - carry on..			stimLMS.scale(ii) = stimLMS.maxScale;		else	      	str = sprintf('Requested contrast ( %.3f) exceeds maximum (%.3f)\n', ...		  	stimLMS.scale(ii),stimLMS.maxScale);      		error(str);		end  	end    % When stimRGB.scale equals stimRGB.maxScale,     %     %      stimLMS.scale = stimLMS.maxScale    %     % Everything is linear, so to obtain     %     %    stimLMS.scale = stimLMS.maxScale * (stimRGB.scale/stimRGB.maxScale)    %     % To solve for the stimRGB.scale that yields a stimLMS.scale,    % we invert    %     stimRGB.scale(ii) = (stimLMS.scale(ii)/stimLMS.maxScale)*stimRGB.maxScale;    %   endreturn