function [LEDstim] = tetra_sensorToPrimary(dpy,stimLMS,sensors)%%function [LEDstim] = tetra_sensorToPrimary(dpy,stimLMS,sensors)%% AUTHOR: Welbourne, Wade (based on findMaxConeScale by Wandell, Baseler% etc)%DATE:   04/22/16%PURPOSE:%%   Calculate the primary values associated with a modulation of a%   particular set of sensor values. Primaries in our case are LEDs,%   sensors are cones. But we can have >3 of either%  % ARGUMENTS%%  display:  .spectra is  a 361xN display primaries%             %  stimLMS:  The field%             .dir     defines the color direction. By convention,%                X.dir is a n-vector with a unit length%             .scale   a single scale factor%             %  backRGB:  .dir    defines the color direction of the primary array. By convention,%                X.dir is a n-vector with a maximum value of 1.0%             .scale  a single scale factor%			  %  sensors:  361x3 matrix of sensor wavelength sensitivities%             (optional, - use Baylor nomogram as default).%% RETURNS%            %             % LEDStim: %          .dir is set to display primary direction corresponding to this%           lms direction. This is unit length. Scale is the length of the%           line (sqrt(sum(....))% 04.13.13 ARW: Now accepts multispectral display and LMS% Set up input defaults%backLED.dir=dpy.backLED.dir(:);backLED.scale=dpy.backLED.scale;if ~isfield(dpy,'LEDspectra')  error('dpy.LEDspectra required');else  led2llms = sensors'*dpy.LEDspectra;  %check if nSensors == nPrimaries  if size(led2llms,1)==size(led2llms,2) %compare num rows to cols in the led2llms matrix      llms2led = inv(led2llms);  else %if the number of sensors and LEDs aren't the same, use pinv      llms2led = pinv(led2llms);   endend% Check whether the background RGB values are within the unit cube% meanLED = backLED.dir(:) .* backLED.scale;% err = checkRange(meanRGB,[0 0 0]',[1 1 1]');% if err ~= 0%   error('meanRGB out of range')% end%  Determine the background LMS direction lmsBack = led2llms*(meanLED);%  Scale stimulus LMS by the background LMSscaledStimLMS = stimLMS.dir(:) .* lmsBack * stimLMS.scale;%  Determine the stimulus LED direction and size. Because the thing we sent%  in has a real length in LMS space%  LEDstim.dir = llms2led*scaledStimLMS;% Almost there. We now want the dir to be unit length and the scale to be% the length of the original line.scaleFactor=norm(LEDstim.dir);LEDstim.dir=LEDstim.dir/scaleFactor;LEDstim.scale=scaleFactor;return